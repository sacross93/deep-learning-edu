"""
그래프 기반 클러스터링 퀴즈

이 퀴즈는 그래프 이론 기초, 커뮤니티 탐지 알고리즘, 모듈성 개념,
그리고 네트워크 분석의 실제 적용에 대한 이해도를 평가합니다.
"""

import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from utils.quiz_utils import QuizManager
import numpy as np
import matplotlib.pyplot as plt

def create_graph_clustering_quiz():
    """그래프 기반 클러스터링 퀴즈 생성"""
    
    quiz_manager = QuizManager("그래프 기반 클러스터링")
    
    # 문제 1: 기본 개념 이해
    quiz_manager.add_question(
        question="그래프 기반 클러스터링에서 '커뮤니티(Community)'의 정의로 가장 적절한 것은?",
        options=[
            "노드 개수가 같은 그룹들",
            "내부 연결은 밀집되고 외부 연결은 희소한 노드 그룹",
            "지리적으로 가까운 노드들의 집합",
            "같은 속성을 가진 노드들의 집합"
        ],
        correct_answer=1,
        explanation="""
정답: 2번 (내부 연결은 밀집되고 외부 연결은 희소한 노드 그룹)

해설:
그래프 클러스터링에서 커뮤니티의 핵심 개념:

**커뮤니티의 특징:**
- **내부 밀집성**: 커뮤니티 내 노드들 간 연결이 많음
- **외부 희소성**: 다른 커뮤니티와의 연결이 적음
- **구조적 정의**: 그래프의 토폴로지 기반

**다른 옵션들의 문제:**
- 노드 개수: 커뮤니티 크기는 다를 수 있음
- 지리적 거리: 그래프에서는 연결 구조가 중요
- 같은 속성: 구조가 아닌 속성 기반 분류

이 정의는 모듈성(modularity) 개념의 기초가 됩니다.
        """
    )
    
    # 문제 2: 모듈성 이해
    quiz_manager.add_question(
        question="모듈성(Modularity) 값이 0.7이라면, 이는 무엇을 의미합니까?",
        options=[
            "70%의 노드가 올바르게 분류되었다",
            "매우 강한 커뮤니티 구조를 가지고 있다",
            "7개의 커뮤니티가 존재한다",
            "네트워크 밀도가 70%이다"
        ],
        correct_answer=1,
        explanation="""
정답: 2번 (매우 강한 커뮤니티 구조를 가지고 있다)

해설:
모듈성(Modularity) 해석:

**모듈성 범위**: [-1, 1]
- **Q > 0.7**: 매우 강한 커뮤니티 구조
- **Q > 0.3**: 유의미한 커뮤니티 구조  
- **Q ≈ 0**: 랜덤 네트워크와 유사
- **Q < 0**: 랜덤보다 약한 구조

**0.7의 의미:**
- 실제 커뮤니티 내 연결이 랜덤 기대값보다 훨씬 많음
- 명확하고 잘 분리된 커뮤니티 구조
- 실제 네트워크에서 매우 높은 수준

**모듈성 공식:**
Q = (1/2m) Σ[A_ij - (k_i×k_j)/(2m)] × δ(c_i, c_j)

여기서 실제 연결과 랜덤 기대값의 차이를 측정합니다.
        """
    )
    
    # 문제 3: Girvan-Newman 알고리즘
    quiz_manager.add_question(
        question="Girvan-Newman 알고리즘에서 제거하는 엣지의 기준은?",
        options=[
            "가장 긴 엣지",
            "가장 높은 가중치를 가진 엣지",
            "가장 높은 중심성(betweenness centrality)을 가진 엣지",
            "가장 많은 삼각형에 포함된 엣지"
        ],
        correct_answer=2,
        explanation="""
정답: 3번 (가장 높은 중심성을 가진 엣지)

해설:
Girvan-Newman 알고리즘의 핵심 아이디어:

**엣지 중심성 (Edge Betweenness Centrality):**
- 모든 최단 경로 중 해당 엣지를 지나는 경로의 비율
- 커뮤니티 간 '다리' 역할을 하는 엣지는 높은 중심성을 가짐

**알고리즘 과정:**
1. 모든 엣지의 중심성 계산
2. 가장 높은 중심성을 가진 엣지 제거
3. 그래프 분리 확인
4. 분리될 때까지 반복

**중심성이 높은 엣지의 특징:**
- 서로 다른 커뮤니티를 연결
- 제거 시 네트워크가 분리됨
- 정보 흐름의 병목점 역할

이 방법은 분할적(divisive) 접근법의 대표적 예시입니다.
        """
    )
    
    # 문제 4: Louvain 알고리즘
    quiz_manager.add_question(
        question="Louvain 알고리즘의 주요 특징으로 옳지 않은 것은?",
        options=[
            "모듈성 최적화를 목표로 한다",
            "계층적 구조를 탐지할 수 있다",
            "항상 전역 최적해를 보장한다",
            "대규모 네트워크에서 효율적이다"
        ],
        correct_answer=2,
        explanation="""
정답: 3번 (항상 전역 최적해를 보장한다)

해설:
Louvain 알고리즘의 특징과 한계:

**주요 특징:**
- **모듈성 최적화**: 그리디 방식으로 모듈성 증가
- **계층적 구조**: 다층 커뮤니티 탐지 가능
- **효율성**: O(n log n) 복잡도로 대규모 네트워크 처리

**한계점:**
- **지역 최적해**: 그리디 알고리즘의 한계
- **해상도 한계**: 작은 커뮤니티 탐지 어려움
- **불안정성**: 초기 조건에 따라 결과 변동

**알고리즘 과정:**
1. 지역 최적화: 각 노드를 최적 커뮤니티로 이동
2. 네트워크 압축: 커뮤니티를 슈퍼노드로 변환
3. 반복: 개선이 없을 때까지 1-2 반복

전역 최적해 보장은 NP-hard 문제의 특성상 불가능합니다.
        """
    )
    
    # 문제 5: Label Propagation
    quiz_manager.add_question(
        question="Label Propagation 알고리즘에서 노드가 새로운 레이블을 선택하는 기준은?",
        options=[
            "자신과 가장 유사한 노드의 레이블",
            "이웃 노드들 중 가장 빈번한 레이블",
            "가장 큰 커뮤니티의 레이블",
            "무작위로 선택된 레이블"
        ],
        correct_answer=1,
        explanation="""
정답: 2번 (이웃 노드들 중 가장 빈번한 레이블)

해설:
Label Propagation의 핵심 원리:

**레이블 전파 규칙:**
- 각 노드는 이웃들의 레이블을 확인
- 가장 많은 이웃이 가진 레이블을 선택
- 동점인 경우 무작위 또는 규칙에 따라 선택

**알고리즘 과정:**
1. 각 노드에 고유 레이블 할당
2. 각 노드가 이웃의 다수 레이블로 업데이트
3. 수렴할 때까지 반복

**장점:**
- 매우 빠른 속도 O(m)
- 구현이 간단
- 파라미터가 거의 없음

**단점:**
- 불안정한 결과 (초기화에 민감)
- 수렴 보장 없음
- 품질이 다른 방법보다 낮을 수 있음

이 방법은 "다수의 의견을 따른다"는 직관적 아이디어에 기반합니다.
        """
    )
    
    # 문제 6: 스펙트럴 클러스터링
    quiz_manager.add_question(
        question="그래프 스펙트럴 클러스터링에서 사용하는 라플라시안 행렬 L의 정의는?",
        options=[
            "L = A (인접 행렬)",
            "L = D (차수 행렬)",
            "L = D - A (차수 행렬 - 인접 행렬)",
            "L = A - D (인접 행렬 - 차수 행렬)"
        ],
        correct_answer=2,
        explanation="""
정답: 3번 (L = D - A)

해설:
라플라시안 행렬의 정의와 특성:

**기본 라플라시안:**
- L = D - A
- D: 차수 행렬 (대각선에 각 노드의 차수)
- A: 인접 행렬

**라플라시안의 특성:**
- 반정부호 행렬 (모든 고유값 ≥ 0)
- 가장 작은 고유값은 항상 0
- 0 고유값의 개수 = 연결 성분의 개수

**정규화 라플라시안:**
- 대칭: L_sym = D^(-1/2) L D^(-1/2)
- 비대칭: L_rw = D^(-1) L

**스펙트럴 클러스터링 과정:**
1. 라플라시안 행렬 계산
2. 가장 작은 k개 고유값의 고유벡터 계산
3. 고유벡터를 특성으로 k-평균 클러스터링

라플라시안의 고유벡터는 그래프의 구조적 정보를 담고 있습니다.
        """
    )
    
    # 문제 7: 네트워크 유형과 알고리즘
    quiz_manager.add_question(
        question="다음 중 소규모 네트워크에서 정확한 커뮤니티 구조를 찾기에 가장 적합한 알고리즘은?",
        options=[
            "Label Propagation (빠른 속도 우선)",
            "Girvan-Newman (정확도 우선)",
            "Louvain (효율성과 정확도 균형)",
            "Random Walk (탐색적 접근)"
        ],
        correct_answer=1,
        explanation="""
정답: 2번 (Girvan-Newman)

해설:
네트워크 규모별 알고리즘 선택:

**소규모 네트워크 (< 1000 노드):**
- **Girvan-Newman**: 높은 정확도, 계산 가능한 복잡도
- 엣지 중심성 기반의 체계적 접근
- 모든 가능한 분할을 고려

**중간 규모 네트워크:**
- **Louvain**: 효율성과 정확도의 균형
- 계층적 구조 탐지 가능
- 실용적 성능

**대규모 네트워크:**
- **Label Propagation**: 속도 우선
- **Fast Unfolding**: Louvain 변형

**Girvan-Newman의 장점 (소규모):**
- 체계적이고 결정론적
- 중간 결과 분석 가능
- 높은 품질의 커뮤니티 탐지

복잡도가 O(m²n)이지만 소규모에서는 문제없습니다.
        """
    )
    
    # 문제 8: 전도성 (Conductance)
    quiz_manager.add_question(
        question="전도성(Conductance) 지표가 낮다는 것은 무엇을 의미합니까?",
        options=[
            "커뮤니티 내부 연결이 적다",
            "커뮤니티가 잘 분리되어 있다",
            "네트워크 밀도가 낮다",
            "노드 개수가 적다"
        ],
        correct_answer=1,
        explanation="""
정답: 2번 (커뮤니티가 잘 분리되어 있다)

해설:
전도성(Conductance)의 개념과 해석:

**전도성 공식:**
φ(S) = cut(S, S̄) / min(vol(S), vol(S̄))

여기서:
- cut(S, S̄): S와 S̄ 사이의 엣지 수
- vol(S): S 내 노드들의 차수 합

**전도성 해석:**
- **낮은 전도성**: 커뮤니티 간 연결이 적음 → 좋은 분할
- **높은 전도성**: 커뮤니티 간 연결이 많음 → 나쁜 분할

**모듈성과의 관계:**
- 전도성 ↓ → 모듈성 ↑
- 둘 다 커뮤니티 품질을 측정하지만 다른 관점

**실제 적용:**
- 전도성 < 0.1: 매우 좋은 커뮤니티
- 전도성 > 0.5: 의미 없는 분할

전도성은 그래프 분할의 품질을 측정하는 중요한 지표입니다.
        """
    )
    
    # 문제 9: 네트워크 유형별 특성
    quiz_manager.add_question(
        question="스케일-프리 네트워크(Scale-free Network)에서 커뮤니티 탐지 시 주의해야 할 점은?",
        options=[
            "모든 노드의 차수가 같아서 구분이 어렵다",
            "허브 노드들이 여러 커뮤니티를 연결하여 분할을 어렵게 만든다",
            "네트워크가 너무 조밀해서 계산이 오래 걸린다",
            "커뮤니티 구조가 전혀 존재하지 않는다"
        ],
        correct_answer=1,
        explanation="""
정답: 2번 (허브 노드들이 여러 커뮤니티를 연결하여 분할을 어렵게 만든다)

해설:
스케일-프리 네트워크의 특성과 커뮤니티 탐지:

**스케일-프리 네트워크 특징:**
- 차수 분포가 멱법칙(power law)을 따름
- 소수의 허브 노드가 많은 연결을 가짐
- 대부분 노드는 적은 연결을 가짐

**커뮤니티 탐지의 어려움:**
- **허브 노드**: 여러 커뮤니티와 연결
- **모호한 소속**: 허브를 어느 커뮤니티에 할당할지 애매
- **분할 방해**: 허브 제거 시 네트워크 크게 변화

**해결 방법:**
- 중첩 커뮤니티 탐지 알고리즘 사용
- 허브 노드의 특별한 처리
- 계층적 접근법 적용

**실제 예시:**
- 소셜 네트워크: 인플루언서가 여러 그룹과 연결
- 웹 그래프: 포털 사이트가 다양한 주제와 연결

이는 실제 네트워크 분석에서 중요한 고려사항입니다.
        """
    )
    
    # 문제 10: 실제 적용 시나리오
    quiz_manager.add_question(
        question="다음 중 그래프 기반 클러스터링이 가장 적합한 응용 분야는?",
        options=[
            "이미지의 픽셀 분류",
            "소셜 네트워크에서 친구 그룹 탐지",
            "시계열 데이터의 패턴 분석",
            "텍스트 문서의 주제 분류"
        ],
        correct_answer=1,
        explanation="""
정답: 2번 (소셜 네트워크에서 친구 그룹 탐지)

해설:
그래프 클러스터링의 적합한 응용 분야:

**최적 적용 분야:**
- **소셜 네트워크**: 친구 관계 → 그래프 구조
- **생물학적 네트워크**: 단백질 상호작용
- **웹 분석**: 하이퍼링크 구조
- **교통 네트워크**: 도로/노선 연결

**소셜 네트워크 분석의 장점:**
- 자연스러운 그래프 구조
- 명확한 관계 정의 (친구, 팔로우 등)
- 커뮤니티 개념이 직관적
- 실용적 가치 높음

**다른 옵션들의 한계:**
- **이미지 픽셀**: 공간적 클러스터링이 더 적합
- **시계열**: 시간적 패턴 분석 필요
- **텍스트**: 의미적 유사도 기반 클러스터링

**실제 활용 사례:**
- Facebook 친구 그룹 추천
- LinkedIn 전문가 네트워크
- Twitter 관심사 커뮤니티
- 학술 협업 네트워크

그래프 구조가 자연스럽게 존재하는 도메인에서 가장 효과적입니다.
        """
    )
    
    return quiz_manager

def main():
    """퀴즈 실행 메인 함수"""
    print("="*60)
    print("그래프 기반 클러스터링 퀴즈")
    print("="*60)
    print()
    print("이 퀴즈는 그래프 클러스터링의 핵심 개념들을 다룹니다:")
    print("• 그래프 이론 기초")
    print("• 커뮤니티와 모듈성 개념")
    print("• 주요 알고리즘 (Girvan-Newman, Louvain, Label Propagation)")
    print("• 스펙트럴 클러스터링")
    print("• 성능 평가 지표")
    print("• 네트워크 유형별 특성")
    print("• 실제 적용 사례")
    print()
    
    # 퀴즈 생성 및 실행
    quiz_manager = create_graph_clustering_quiz()
    results = quiz_manager.run_quiz()
    
    # 결과 출력
    print("\n" + "="*60)
    print("퀴즈 결과 분석")
    print("="*60)
    
    score = results['score']
    total = results['total']
    percentage = results['percentage']
    
    print(f"총 점수: {score}/{total} ({percentage:.1f}%)")
    
    if percentage >= 90:
        print("🏆 훌륭합니다! 그래프 클러스터링을 완벽하게 이해하고 있습니다.")
    elif percentage >= 80:
        print("👍 잘했습니다! 그래프 클러스터링의 핵심 개념을 잘 파악하고 있습니다.")
    elif percentage >= 70:
        print("👌 괜찮습니다! 몇 가지 개념을 더 복습해보세요.")
    elif percentage >= 60:
        print("📚 더 공부가 필요합니다. 이론 문서를 다시 읽어보세요.")
    else:
        print("💪 포기하지 마세요! 기초부터 차근차근 다시 학습해보세요.")
    
    # 틀린 문제 분석
    wrong_questions = results['wrong_questions']
    if wrong_questions:
        print(f"\n틀린 문제: {len(wrong_questions)}개")
        print("다음 주제들을 더 공부해보세요:")
        
        topics = {
            1: "커뮤니티 기본 개념",
            2: "모듈성 이해",
            3: "Girvan-Newman 알고리즘",
            4: "Louvain 알고리즘",
            5: "Label Propagation",
            6: "스펙트럴 클러스터링",
            7: "알고리즘 선택 기준",
            8: "전도성 지표",
            9: "네트워크 유형별 특성",
            10: "실제 적용 시나리오"
        }
        
        for q_num in wrong_questions:
            print(f"  • {topics.get(q_num, f'문제 {q_num}')}")
    
    print("\n" + "="*60)
    print("학습 권장사항")
    print("="*60)
    
    if percentage < 70:
        print("📖 15_graph_clustering_theory.md 문서를 다시 읽어보세요.")
        print("💻 15_graph_clustering_practice.py 실습을 다시 실행해보세요.")
    
    print("🔍 추가 학습 주제:")
    print("  • 동적 네트워크에서의 커뮤니티 탐지")
    print("  • 중첩 커뮤니티 탐지 알고리즘")
    print("  • 다층 네트워크 분석")
    print("  • 대규모 네트워크를 위한 분산 알고리즘")
    
    return results

if __name__ == "__main__":
    main()