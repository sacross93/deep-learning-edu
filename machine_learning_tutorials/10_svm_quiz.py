"""
SVM (Support Vector Machine) 퀴즈

이 퀴즈는 SVM의 핵심 개념, 커널 함수, 하이퍼파라미터 등에 대한 
이해도를 확인합니다.
"""

import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from utils.quiz_utils import Quiz, Question

def create_svm_quiz():
    """SVM 퀴즈 생성"""
    
    quiz = Quiz("SVM (Support Vector Machine) 퀴즈")
    
    # 1. SVM 기본 개념
    quiz.add_question(Question(
        "SVM의 주요 목표는 무엇인가요?",
        "multiple_choice",
        ["정확도를 최대화하는 것", "마진을 최대화하는 것", "훈련 시간을 최소화하는 것", "특성 수를 줄이는 것"],
        1,
        "SVM의 핵심 아이디어는 클래스 간의 마진(margin)을 최대화하는 초평면을 찾는 것입니다. "
        "마진이 클수록 새로운 데이터에 대한 일반화 성능이 향상됩니다."
    ))
    
    # 2. 서포트 벡터 개념
    quiz.add_question(Question(
        "서포트 벡터(Support Vector)에 대한 설명으로 올바른 것은?",
        "multiple_choice",
        [
            "모든 훈련 데이터가 서포트 벡터이다",
            "결정 경계에서 가장 먼 데이터 포인트들이다",
            "결정 경계에 가장 가까운 데이터 포인트들이다",
            "잘못 분류된 데이터 포인트들이다"
        ],
        2,
        "서포트 벡터는 결정 경계에 가장 가까이 위치한 데이터 포인트들입니다. "
        "이들만이 결정 경계의 위치를 결정하며, 다른 데이터 포인트들을 제거해도 "
        "결정 경계는 변하지 않습니다."
    ))
    
    # 3. 커널 트릭
    quiz.add_question(Question(
        "커널 트릭(Kernel Trick)의 주요 장점은 무엇인가요?",
        "multiple_choice",
        [
            "훈련 시간을 단축시킨다",
            "메모리 사용량을 줄인다",
            "고차원 매핑 없이 비선형 분류를 가능하게 한다",
            "특성 선택을 자동화한다"
        ],
        2,
        "커널 트릭은 데이터를 명시적으로 고차원 공간으로 매핑하지 않고도 "
        "고차원에서의 내적을 계산할 수 있게 해줍니다. 이를 통해 비선형 분류가 "
        "가능하면서도 차원의 저주를 피할 수 있습니다."
    ))
    
    # 4. RBF 커널
    quiz.add_question(Question(
        "RBF(Radial Basis Function) 커널에서 gamma 파라미터가 높을 때의 효과는?",
        "multiple_choice",
        [
            "더 부드러운 결정 경계를 만든다",
            "더 복잡한 결정 경계를 만들어 과적합 위험이 증가한다",
            "훈련 시간이 단축된다",
            "서포트 벡터 수가 감소한다"
        ],
        1,
        "gamma가 높으면 개별 훈련 샘플의 영향 범위가 좁아져서 더 복잡한 결정 경계를 "
        "만들게 됩니다. 이는 과적합 위험을 증가시킬 수 있습니다."
    ))
    
    # 5. C 파라미터
    quiz.add_question(Question(
        "SVM의 C 파라미터에 대한 설명으로 올바른 것은?",
        "multiple_choice",
        [
            "C가 클수록 마진을 최대화하는 것을 우선시한다",
            "C가 클수록 오분류에 대한 페널티가 커진다",
            "C는 커널 함수의 모양을 결정한다",
            "C는 특성의 개수와 관련이 있다"
        ],
        1,
        "C는 정규화 매개변수로, 오분류에 대한 페널티 강도를 조절합니다. "
        "C가 클수록 오분류를 더 강하게 페널티를 주어 복잡한 결정 경계를 만들고, "
        "C가 작을수록 마진 최대화를 우선시하여 단순한 결정 경계를 만듭니다."
    ))
    
    # 6. 커널 선택
    quiz.add_question(Question(
        "다음 상황에서 가장 적절한 커널은 무엇인가요?\n"
        "상황: 텍스트 분류 문제로 특성 수가 매우 많고(고차원), 데이터가 선형 분리 가능할 것으로 예상됨",
        "multiple_choice",
        ["Linear 커널", "RBF 커널", "Polynomial 커널", "Sigmoid 커널"],
        0,
        "고차원 데이터에서 선형 분리가 가능한 경우 Linear 커널이 가장 적합합니다. "
        "텍스트 데이터는 일반적으로 고차원이며, TF-IDF와 같은 특성 변환 후에는 "
        "선형 분리가 가능한 경우가 많습니다. Linear 커널은 빠르고 해석하기 쉽습니다."
    ))
    
    # 7. 스케일링의 중요성
    quiz.add_question(Question(
        "SVM에서 특성 스케일링이 중요한 이유는?",
        "multiple_choice",
        [
            "훈련 시간을 단축시키기 위해",
            "메모리 사용량을 줄이기 위해",
            "거리 기반 알고리즘이므로 특성 간 스케일 차이가 성능에 영향을 미치기 때문",
            "과적합을 방지하기 위해"
        ],
        2,
        "SVM은 거리 기반 알고리즘으로, 특성 간 스케일 차이가 클 경우 "
        "큰 값을 가진 특성이 결정 경계에 과도한 영향을 미칠 수 있습니다. "
        "따라서 StandardScaler 등을 사용한 특성 스케일링이 필수적입니다."
    ))
    
    # 8. 다중 클래스 분류
    quiz.add_question(Question(
        "SVM에서 다중 클래스 분류를 처리하는 일반적인 방법은?",
        "multiple_choice",
        [
            "각 클래스별로 별도의 특성을 사용한다",
            "One-vs-One 또는 One-vs-Rest 전략을 사용한다",
            "클래스를 이진으로 인코딩한다",
            "클러스터링을 먼저 수행한다"
        ],
        1,
        "SVM은 본질적으로 이진 분류기이므로, 다중 클래스 문제를 해결하기 위해 "
        "One-vs-One(모든 클래스 쌍에 대해 분류기 훈련) 또는 "
        "One-vs-Rest(각 클래스 vs 나머지 클래스) 전략을 사용합니다."
    ))
    
    # 9. 계산 복잡도
    quiz.add_question(Question(
        "SVM의 훈련 시간 복잡도에 대한 설명으로 올바른 것은?",
        "multiple_choice",
        [
            "O(n)으로 선형적이다",
            "O(n log n)이다",
            "O(n²)에서 O(n³) 사이이다",
            "특성 수에만 의존한다"
        ],
        2,
        "SVM의 훈련 시간 복잡도는 일반적으로 O(n²)에서 O(n³) 사이입니다. "
        "이는 이차 계획법(Quadratic Programming) 문제를 해결해야 하기 때문이며, "
        "대용량 데이터에서 훈련 시간이 오래 걸리는 이유입니다."
    ))
    
    # 10. 확률 출력
    quiz.add_question(Question(
        "SVM에서 확률 추정을 얻는 방법은?",
        "multiple_choice",
        [
            "SVM은 직접적으로 확률을 출력한다",
            "decision_function() 값을 시그모이드 함수로 변환한다",
            "predict_proba() 메서드를 사용한다 (probability=True 설정 필요)",
            "서포트 벡터의 비율을 사용한다"
        ],
        2,
        "SVM은 기본적으로 확률을 출력하지 않고 결정 함수 값을 제공합니다. "
        "확률 추정이 필요한 경우 SVC(probability=True)로 설정하여 "
        "내부적으로 Platt scaling을 사용한 확률 보정을 수행할 수 있습니다."
    ))
    
    # 11. 시나리오 기반 문제
    quiz.add_question(Question(
        "다음 상황에서 SVM 성능을 개선하기 위한 가장 우선적인 조치는?\n"
        "상황: 훈련 정확도 99%, 테스트 정확도 75%, 서포트 벡터 비율이 매우 높음",
        "multiple_choice",
        [
            "C 값을 증가시킨다",
            "C 값을 감소시킨다",
            "gamma 값을 증가시킨다",
            "더 복잡한 커널을 사용한다"
        ],
        1,
        "훈련 정확도가 매우 높고 테스트 정확도가 낮으며 서포트 벡터 비율이 높다는 것은 "
        "과적합의 전형적인 증상입니다. C 값을 감소시켜 정규화를 강화하면 "
        "마진을 넓혀 일반화 성능을 향상시킬 수 있습니다."
    ))
    
    # 12. 실제 적용 문제
    quiz.add_question(Question(
        "의료 진단 시스템에서 SVM을 사용할 때 가장 중요한 고려사항은?",
        "multiple_choice",
        [
            "훈련 속도를 최대한 빠르게 한다",
            "정확도보다 재현율(민감도)을 우선시한다",
            "모델의 해석 가능성을 높인다",
            "메모리 사용량을 최소화한다"
        ],
        1,
        "의료 진단에서는 실제 양성(질병)을 놓치는 것(False Negative)이 "
        "매우 위험하므로 재현율(민감도)을 우선시해야 합니다. "
        "이는 실제 환자를 건강하다고 잘못 진단하는 것을 최소화하기 위함입니다."
    ))
    
    # 13. 하이퍼파라미터 튜닝 전략
    quiz.add_question(Question(
        "SVM 하이퍼파라미터 튜닝에서 권장되는 접근 방법은?",
        "multiple_choice",
        [
            "C와 gamma를 동시에 큰 범위에서 그리드 서치",
            "먼저 선형 커널로 시작하여 점진적으로 복잡한 커널 시도",
            "gamma를 먼저 고정하고 C만 튜닝",
            "랜덤하게 파라미터 조합 선택"
        ],
        1,
        "효율적인 SVM 튜닝을 위해서는 먼저 선형 커널로 기준선을 설정하고, "
        "필요에 따라 RBF 등 더 복잡한 커널을 시도하는 것이 좋습니다. "
        "이렇게 하면 데이터의 특성을 파악하고 불필요한 복잡성을 피할 수 있습니다."
    ))
    
    # 14. 메모리 효율성
    quiz.add_question(Question(
        "SVM이 메모리 효율적인 이유는?",
        "multiple_choice",
        [
            "모든 훈련 데이터를 저장할 필요가 없다",
            "서포트 벡터만 저장하면 되기 때문이다",
            "특성을 압축해서 저장한다",
            "커널 함수가 메모리를 절약한다"
        ],
        1,
        "SVM은 예측 시 서포트 벡터만 필요하므로 메모리 효율적입니다. "
        "전체 훈련 데이터를 저장할 필요 없이 결정 경계를 결정하는 "
        "핵심 데이터 포인트들(서포트 벡터)만 보관하면 됩니다."
    ))
    
    # 15. 종합 이해 문제
    quiz.add_question(Question(
        "다음 중 SVM의 장점이 아닌 것은?",
        "multiple_choice",
        [
            "고차원 데이터에서 효과적이다",
            "과적합에 강하다",
            "빠른 예측 속도를 제공한다",
            "확률 출력을 직접 제공한다"
        ],
        3,
        "SVM은 기본적으로 확률을 출력하지 않고 결정 함수 값을 제공합니다. "
        "확률이 필요한 경우 별도의 보정 과정이 필요합니다. "
        "다른 옵션들은 모두 SVM의 장점에 해당합니다."
    ))
    
    return quiz

def main():
    """퀴즈 실행"""
    print("=" * 60)
    print("SVM (Support Vector Machine) 퀴즈")
    print("=" * 60)
    print("SVM의 핵심 개념, 커널 함수, 하이퍼파라미터에 대한 이해도를 확인합니다.")
    print("각 문제를 신중히 읽고 답변해주세요.")
    print("-" * 60)
    
    quiz = create_svm_quiz()
    score = quiz.run()
    
    # 점수별 피드백
    print(f"\n최종 점수: {score}/{quiz.total_questions}")
    print(f"정답률: {score/quiz.total_questions*100:.1f}%")
    
    if score == quiz.total_questions:
        print("🎉 완벽합니다! SVM에 대한 이해가 매우 뛰어납니다!")
        print("실제 프로젝트에서 SVM을 효과적으로 활용할 수 있을 것입니다.")
    elif score >= quiz.total_questions * 0.8:
        print("👍 우수합니다! SVM의 핵심 개념을 잘 이해하고 있습니다.")
        print("몇 가지 세부사항을 더 학습하면 완벽할 것입니다.")
    elif score >= quiz.total_questions * 0.6:
        print("📚 양호합니다. SVM의 기본 개념은 이해하고 있습니다.")
        print("커널 함수와 하이퍼파라미터 튜닝 부분을 더 학습해보세요.")
    else:
        print("💪 더 학습이 필요합니다.")
        print("SVM 이론 문서를 다시 읽고 실습을 통해 개념을 익혀보세요.")
    
    # 학습 권장사항
    print("\n📖 추가 학습 권장사항:")
    print("1. 다양한 데이터셋으로 SVM 실습해보기")
    print("2. 커널 함수별 특성과 적용 상황 이해하기")
    print("3. 하이퍼파라미터 튜닝 전략 실습하기")
    print("4. 다른 분류 알고리즘과의 성능 비교 분석하기")
    print("5. 실제 프로젝트에서 SVM 적용해보기")

if __name__ == "__main__":
    main()